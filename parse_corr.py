#!/usr/bin/env python

# A script to parse output correlator files generated by the MILC spectrum_ks code
# USAGE: run: parseCorr corrFileName
# corrFileName is the correlator file to be parsed

import pandas as pd
import numpy as np
import scipy
import re
import sys
import scikits.bootstrap as bootstrap

# reads input file name
inFileName=str(sys.argv[1])

# counting total number of configs
configNCounter = 1
with open(inFileName) as file:
    for line in file:
       match = re.search('---', line)
       if match:
            configNCounter = configNCounter + 1

configTotalNumber = configNCounter/7 # 7 instances of '---' per config

# Reading lattice temporal extent from first lattice_size instance
with open(inFileName) as file:
    for line in file:
       match = re.search('lattice_size:', line)
       if match:
           latticeTsize = int(line[-3:-1])
           break

#Initializing np.arrays that will receive correlator data
pionPSCorrelator = np.zeros(shape=(configTotalNumber,latticeTsize))
pionSCCorrelator = np.zeros(shape=(configTotalNumber,latticeTsize))
rhoVTCorrelator = np.zeros(shape=(configTotalNumber,latticeTsize))
rhoPVCorrelator = np.zeros(shape=(configTotalNumber,latticeTsize))
nucleonCorrelator = np.zeros(shape=(configTotalNumber,latticeTsize))

# Parsing correlator data
configCounter = -1

print "Parsing begun!"
with open(inFileName) as file:
    for line in file:
        if line.startswith( 'correlator:', 0):              #Sets correct propagator type 
            corrtype = line.split()[1]
            if corrtype == "PION_PS":
                configCounter = configCounter + 1
            else:
                continue
               
# Storing propagator data inside np.arrays                 
        else:
            if line[0].isdigit():
                if corrtype == "PION_PS":
                    pionPSCorrelator[int(configCounter)][int(line.split()[0])]=float(line.split()[1])
                elif corrtype == "PION_SC":
                    pionSCCorrelator[int(configCounter)][int(line.split()[0])]=float(line.split()[1])
                elif corrtype == "RHO_VT":
                    rhoVTCorrelator[int(configCounter)][int(line.split()[0])]=float(line.split()[1])
                elif corrtype == "RHO_PV":
                    rhoPVCorrelator[int(configCounter)][int(line.split()[0])]=float(line.split()[1])
                elif corrtype == "NUCLEON":
                    nucleonCorrelator[int(configCounter)][int(line.split()[0])]=float(line.split()[1])
                else:
                    continue
            
# Building DataFrames from np.arrays generated before    
pionPSFrame = pd.DataFrame(pionPSCorrelator)
pionSCFrame = pd.DataFrame(pionSCCorrelator)
rhoVTFrame = pd.DataFrame(rhoVTCorrelator)
rhoPVFrame = pd.DataFrame(rhoPVCorrelator)
nucleonFrame = pd.DataFrame(nucleonCorrelator)
print "Data parsed. Pickling RAW data..."

# Exporting each DataFrame to a serial backup for later reference
pionPSFrame.save('pion_PS.pickle')
pionSCFrame.save('pion_SC.pickle')
rhoVTFrame.save('rho_VT.pickle')
rhoPVFrame.save('rho_PV.pickle')
nucleonFrame.save('nucleon.pickle')
print "Pickled!"

# computing bootstraped errors for each correlator
pionPSErr = np.zeros(shape=(1,latticeTsize))
pionSCErr = np.zeros(shape=(1,latticeTsize))
rhoVTErr = np.zeros(shape=(1,latticeTsize))
rhoPVErr = np.zeros(shape=(1,latticeTsize))
nucleonErr = np.zeros(shape=(1,latticeTsize))

corrErr = [pionPSErr, pionSCErr, rhoVTErr, rhoPVErr, nucleonErr]
listOfFrames=[pionPSFrame, pionSCFrame, rhoVTFrame, rhoPVFrame, nucleonFrame ]

# bootstraped errors are calculated here
print "Now bootstrapping. Just a sec... OK, maybe a bit more..."
for i in range(0,5):
    #print float(i+1)*100/len(listOfFrames), "%"
    for j in range(0, latticeTsize):
        corrMean = listOfFrames[i][j].mean()
        CIs = bootstrap.ci(data=listOfFrames[i][j], statfunction=scipy.mean, n_samples=20000)
        corrErr[i][0][j]=((CIs[1]-corrMean)+(corrMean-CIs[0]))/2
    print str(int(float(i+1)*100/len(listOfFrames)))+"%"

# Summarizing results and exporting to an csv
print "Bootstrap completed! Now Summarizing results and exporting."    
averagesWErr = { 'pion_PS' : pd.Series(pionPSFrame.mean()), 'pion_PS_err': pionPSErr[0], 'pion_SC':  pd.Series(pionSCFrame.mean()), 'pion_SC_err': pionSCErr[0], 
    'rho_VT':  pd.Series(rhoVTFrame.mean()), 'rho_VT_err': rhoVTErr[0], 'rho_PV':  pd.Series(rhoPVFrame.mean()), 'rho_PV_err': rhoPVErr[0],
    'nucleon':  pd.Series(nucleonFrame.mean()), 'nucleon_err': nucleonErr[0] }
pd.DataFrame(averagesWErr).to_csv('spectrum_overview.tsv', sep="\t")

print "Done! Overview exported to spectrum_overview.tsv"